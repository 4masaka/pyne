#
# Autogenerated by Frugal Compiler (3.4.9)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from frugal.util import make_hashable
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol


class ErrorCode(int):
    ILLEGAL_ARGUMENT = 0
    AUTHENTICATION_FAILED = 1
    DB_FAILED = 2
    INVALID_STATE = 3
    EXCESSIVE_ACCESS = 4
    NOT_FOUND = 5
    INVALID_MID = 9
    NOT_A_MEMBER = 10
    INVALID_LENGTH = 6
    NOT_AVAILABLE_USER = 7
    NOT_AUTHORIZED_DEVICE = 8
    NOT_AUTHORIZED_SESSION = 14
    INCOMPATIBLE_APP_VERSION = 11
    NOT_READY = 12
    NOT_AVAILABLE_SESSION = 13
    SYSTEM_ERROR = 15
    NO_AVAILABLE_VERIFICATION_METHOD = 16
    NOT_AUTHENTICATED = 17
    INVALID_IDENTITY_CREDENTIAL = 18
    NOT_AVAILABLE_IDENTITY_IDENTIFIER = 19
    INTERNAL_ERROR = 20
    NO_SUCH_IDENTITY_IDENFIER = 21
    DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY = 22
    ILLEGAL_IDENTITY_CREDENTIAL = 23
    UNKNOWN_CHANNEL = 24
    NO_SUCH_MESSAGE_BOX = 25
    NOT_AVAILABLE_MESSAGE_BOX = 26
    CHANNEL_DOES_NOT_MATCH = 27
    NOT_YOUR_MESSAGE = 28
    MESSAGE_DEFINED_ERROR = 29
    USER_CANNOT_ACCEPT_PRESENTS = 30
    USER_NOT_STICKER_OWNER = 32
    MAINTENANCE_ERROR = 33
    ACCOUNT_NOT_MATCHED = 34
    ABUSE_BLOCK = 35
    NOT_FRIEND = 36
    NOT_ALLOWED_CALL = 37
    BLOCK_FRIEND = 38
    INCOMPATIBLE_VOIP_VERSION = 39
    INVALID_SNS_ACCESS_TOKEN = 40
    EXTERNAL_SERVICE_NOT_AVAILABLE = 41
    NOT_ALLOWED_ADD_CONTACT = 42
    NOT_CERTIFICATED = 43
    NOT_ALLOWED_SECONDARY_DEVICE = 44
    INVALID_PIN_CODE = 45
    NOT_FOUND_IDENTITY_CREDENTIAL = 46
    EXCEED_FILE_MAX_SIZE = 47
    EXCEED_DAILY_QUOTA = 48
    NOT_SUPPORT_SEND_FILE = 49
    MUST_UPGRADE = 50
    NOT_AVAILABLE_PIN_CODE_SESSION = 51
    EXPIRED_REVISION = 52
    NOT_YET_PHONE_NUMBER = 54
    BAD_CALL_NUMBER = 55
    UNAVAILABLE_CALL_NUMBER = 56
    NOT_SUPPORT_CALL_SERVICE = 57
    CONGESTION_CONTROL = 58
    NO_BALANCE = 59
    NOT_PERMITTED_CALLER_ID = 60
    NO_CALLER_ID_LIMIT_EXCEEDED = 61
    CALLER_ID_VERIFICATION_REQUIRED = 62
    NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED = 63
    MESSAGE_NOT_FOUND = 64
    INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT = 65
    ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED = 66
    ACCOUNT_MIGRATION_PINCODE_BLOCKED = 67
    INVALID_PASSWORD_FORMAT = 69
    FEATURE_RESTRICTED = 70
    MESSAGE_NOT_DESTRUCTIBLE = 71
    PAID_CALL_REDEEM_FAILED = 72
    PREVENTED_JOIN_BY_TICKET = 73
    SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT = 75
    SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY = 76
    SECURITY_CENTER_NOT_VERIFIED = 77
    SECURITY_CENTER_BLOCKED_BY_SETTING = 78
    SECURITY_CENTER_BLOCKED = 79
    TALK_PROXY_EXCEPTION = 80
    E2EE_INVALID_PROTOCOL = 81
    E2EE_RETRY_ENCRYPT = 82
    E2EE_UPDATE_SENDER_KEY = 83
    E2EE_UPDATE_RECEIVER_KEY = 84
    E2EE_INVALID_ARGUMENT = 85
    E2EE_INVALID_VERSION = 86
    E2EE_SENDER_DISABLED = 87
    E2EE_RECEIVER_DISABLED = 88
    E2EE_SENDER_NOT_ALLOWED = 89
    E2EE_RECEIVER_NOT_ALLOWED = 90
    E2EE_RESEND_FAIL = 91
    E2EE_RESEND_OK = 92
    HITOKOTO_BACKUP_NO_AVAILABLE_DATA = 93
    E2EE_UPDATE_PRIMARY_DEVICE = 94
    SUCCESS = 95
    CANCEL = 96
    E2EE_PRIMARY_NOT_SUPPORT = 97
    E2EE_RETRY_PLAIN = 98
    E2EE_RECREATE_GROUP_KEY = 99
    E2EE_GROUP_TOO_MANY_MEMBERS = 100
    SERVER_BUSY = 101
    NOT_ALLOWED_ADD_FOLLOW = 102
    INCOMING_FRIEND_REQUEST_LIMIT = 103
    OUTGOING_FRIEND_REQUEST_LIMIT = 104
    OUTGOING_FRIEND_REQUEST_QUOTA = 105
    DUPLICATED = 106
    BANNED = 107

    _VALUES_TO_NAMES = {
        0: "ILLEGAL_ARGUMENT",
        1: "AUTHENTICATION_FAILED",
        2: "DB_FAILED",
        3: "INVALID_STATE",
        4: "EXCESSIVE_ACCESS",
        5: "NOT_FOUND",
        9: "INVALID_MID",
        10: "NOT_A_MEMBER",
        6: "INVALID_LENGTH",
        7: "NOT_AVAILABLE_USER",
        8: "NOT_AUTHORIZED_DEVICE",
        14: "NOT_AUTHORIZED_SESSION",
        11: "INCOMPATIBLE_APP_VERSION",
        12: "NOT_READY",
        13: "NOT_AVAILABLE_SESSION",
        15: "SYSTEM_ERROR",
        16: "NO_AVAILABLE_VERIFICATION_METHOD",
        17: "NOT_AUTHENTICATED",
        18: "INVALID_IDENTITY_CREDENTIAL",
        19: "NOT_AVAILABLE_IDENTITY_IDENTIFIER",
        20: "INTERNAL_ERROR",
        21: "NO_SUCH_IDENTITY_IDENFIER",
        22: "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY",
        23: "ILLEGAL_IDENTITY_CREDENTIAL",
        24: "UNKNOWN_CHANNEL",
        25: "NO_SUCH_MESSAGE_BOX",
        26: "NOT_AVAILABLE_MESSAGE_BOX",
        27: "CHANNEL_DOES_NOT_MATCH",
        28: "NOT_YOUR_MESSAGE",
        29: "MESSAGE_DEFINED_ERROR",
        30: "USER_CANNOT_ACCEPT_PRESENTS",
        32: "USER_NOT_STICKER_OWNER",
        33: "MAINTENANCE_ERROR",
        34: "ACCOUNT_NOT_MATCHED",
        35: "ABUSE_BLOCK",
        36: "NOT_FRIEND",
        37: "NOT_ALLOWED_CALL",
        38: "BLOCK_FRIEND",
        39: "INCOMPATIBLE_VOIP_VERSION",
        40: "INVALID_SNS_ACCESS_TOKEN",
        41: "EXTERNAL_SERVICE_NOT_AVAILABLE",
        42: "NOT_ALLOWED_ADD_CONTACT",
        43: "NOT_CERTIFICATED",
        44: "NOT_ALLOWED_SECONDARY_DEVICE",
        45: "INVALID_PIN_CODE",
        46: "NOT_FOUND_IDENTITY_CREDENTIAL",
        47: "EXCEED_FILE_MAX_SIZE",
        48: "EXCEED_DAILY_QUOTA",
        49: "NOT_SUPPORT_SEND_FILE",
        50: "MUST_UPGRADE",
        51: "NOT_AVAILABLE_PIN_CODE_SESSION",
        52: "EXPIRED_REVISION",
        54: "NOT_YET_PHONE_NUMBER",
        55: "BAD_CALL_NUMBER",
        56: "UNAVAILABLE_CALL_NUMBER",
        57: "NOT_SUPPORT_CALL_SERVICE",
        58: "CONGESTION_CONTROL",
        59: "NO_BALANCE",
        60: "NOT_PERMITTED_CALLER_ID",
        61: "NO_CALLER_ID_LIMIT_EXCEEDED",
        62: "CALLER_ID_VERIFICATION_REQUIRED",
        63: "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED",
        64: "MESSAGE_NOT_FOUND",
        65: "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT",
        66: "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED",
        67: "ACCOUNT_MIGRATION_PINCODE_BLOCKED",
        69: "INVALID_PASSWORD_FORMAT",
        70: "FEATURE_RESTRICTED",
        71: "MESSAGE_NOT_DESTRUCTIBLE",
        72: "PAID_CALL_REDEEM_FAILED",
        73: "PREVENTED_JOIN_BY_TICKET",
        75: "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT",
        76: "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY",
        77: "SECURITY_CENTER_NOT_VERIFIED",
        78: "SECURITY_CENTER_BLOCKED_BY_SETTING",
        79: "SECURITY_CENTER_BLOCKED",
        80: "TALK_PROXY_EXCEPTION",
        81: "E2EE_INVALID_PROTOCOL",
        82: "E2EE_RETRY_ENCRYPT",
        83: "E2EE_UPDATE_SENDER_KEY",
        84: "E2EE_UPDATE_RECEIVER_KEY",
        85: "E2EE_INVALID_ARGUMENT",
        86: "E2EE_INVALID_VERSION",
        87: "E2EE_SENDER_DISABLED",
        88: "E2EE_RECEIVER_DISABLED",
        89: "E2EE_SENDER_NOT_ALLOWED",
        90: "E2EE_RECEIVER_NOT_ALLOWED",
        91: "E2EE_RESEND_FAIL",
        92: "E2EE_RESEND_OK",
        93: "HITOKOTO_BACKUP_NO_AVAILABLE_DATA",
        94: "E2EE_UPDATE_PRIMARY_DEVICE",
        95: "SUCCESS",
        96: "CANCEL",
        97: "E2EE_PRIMARY_NOT_SUPPORT",
        98: "E2EE_RETRY_PLAIN",
        99: "E2EE_RECREATE_GROUP_KEY",
        100: "E2EE_GROUP_TOO_MANY_MEMBERS",
        101: "SERVER_BUSY",
        102: "NOT_ALLOWED_ADD_FOLLOW",
        103: "INCOMING_FRIEND_REQUEST_LIMIT",
        104: "OUTGOING_FRIEND_REQUEST_LIMIT",
        105: "OUTGOING_FRIEND_REQUEST_QUOTA",
        106: "DUPLICATED",
        107: "BANNED",
    }

    _NAMES_TO_VALUES = {
        "ILLEGAL_ARGUMENT": 0,
        "AUTHENTICATION_FAILED": 1,
        "DB_FAILED": 2,
        "INVALID_STATE": 3,
        "EXCESSIVE_ACCESS": 4,
        "NOT_FOUND": 5,
        "INVALID_MID": 9,
        "NOT_A_MEMBER": 10,
        "INVALID_LENGTH": 6,
        "NOT_AVAILABLE_USER": 7,
        "NOT_AUTHORIZED_DEVICE": 8,
        "NOT_AUTHORIZED_SESSION": 14,
        "INCOMPATIBLE_APP_VERSION": 11,
        "NOT_READY": 12,
        "NOT_AVAILABLE_SESSION": 13,
        "SYSTEM_ERROR": 15,
        "NO_AVAILABLE_VERIFICATION_METHOD": 16,
        "NOT_AUTHENTICATED": 17,
        "INVALID_IDENTITY_CREDENTIAL": 18,
        "NOT_AVAILABLE_IDENTITY_IDENTIFIER": 19,
        "INTERNAL_ERROR": 20,
        "NO_SUCH_IDENTITY_IDENFIER": 21,
        "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY": 22,
        "ILLEGAL_IDENTITY_CREDENTIAL": 23,
        "UNKNOWN_CHANNEL": 24,
        "NO_SUCH_MESSAGE_BOX": 25,
        "NOT_AVAILABLE_MESSAGE_BOX": 26,
        "CHANNEL_DOES_NOT_MATCH": 27,
        "NOT_YOUR_MESSAGE": 28,
        "MESSAGE_DEFINED_ERROR": 29,
        "USER_CANNOT_ACCEPT_PRESENTS": 30,
        "USER_NOT_STICKER_OWNER": 32,
        "MAINTENANCE_ERROR": 33,
        "ACCOUNT_NOT_MATCHED": 34,
        "ABUSE_BLOCK": 35,
        "NOT_FRIEND": 36,
        "NOT_ALLOWED_CALL": 37,
        "BLOCK_FRIEND": 38,
        "INCOMPATIBLE_VOIP_VERSION": 39,
        "INVALID_SNS_ACCESS_TOKEN": 40,
        "EXTERNAL_SERVICE_NOT_AVAILABLE": 41,
        "NOT_ALLOWED_ADD_CONTACT": 42,
        "NOT_CERTIFICATED": 43,
        "NOT_ALLOWED_SECONDARY_DEVICE": 44,
        "INVALID_PIN_CODE": 45,
        "NOT_FOUND_IDENTITY_CREDENTIAL": 46,
        "EXCEED_FILE_MAX_SIZE": 47,
        "EXCEED_DAILY_QUOTA": 48,
        "NOT_SUPPORT_SEND_FILE": 49,
        "MUST_UPGRADE": 50,
        "NOT_AVAILABLE_PIN_CODE_SESSION": 51,
        "EXPIRED_REVISION": 52,
        "NOT_YET_PHONE_NUMBER": 54,
        "BAD_CALL_NUMBER": 55,
        "UNAVAILABLE_CALL_NUMBER": 56,
        "NOT_SUPPORT_CALL_SERVICE": 57,
        "CONGESTION_CONTROL": 58,
        "NO_BALANCE": 59,
        "NOT_PERMITTED_CALLER_ID": 60,
        "NO_CALLER_ID_LIMIT_EXCEEDED": 61,
        "CALLER_ID_VERIFICATION_REQUIRED": 62,
        "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED": 63,
        "MESSAGE_NOT_FOUND": 64,
        "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT": 65,
        "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED": 66,
        "ACCOUNT_MIGRATION_PINCODE_BLOCKED": 67,
        "INVALID_PASSWORD_FORMAT": 69,
        "FEATURE_RESTRICTED": 70,
        "MESSAGE_NOT_DESTRUCTIBLE": 71,
        "PAID_CALL_REDEEM_FAILED": 72,
        "PREVENTED_JOIN_BY_TICKET": 73,
        "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT": 75,
        "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY": 76,
        "SECURITY_CENTER_NOT_VERIFIED": 77,
        "SECURITY_CENTER_BLOCKED_BY_SETTING": 78,
        "SECURITY_CENTER_BLOCKED": 79,
        "TALK_PROXY_EXCEPTION": 80,
        "E2EE_INVALID_PROTOCOL": 81,
        "E2EE_RETRY_ENCRYPT": 82,
        "E2EE_UPDATE_SENDER_KEY": 83,
        "E2EE_UPDATE_RECEIVER_KEY": 84,
        "E2EE_INVALID_ARGUMENT": 85,
        "E2EE_INVALID_VERSION": 86,
        "E2EE_SENDER_DISABLED": 87,
        "E2EE_RECEIVER_DISABLED": 88,
        "E2EE_SENDER_NOT_ALLOWED": 89,
        "E2EE_RECEIVER_NOT_ALLOWED": 90,
        "E2EE_RESEND_FAIL": 91,
        "E2EE_RESEND_OK": 92,
        "HITOKOTO_BACKUP_NO_AVAILABLE_DATA": 93,
        "E2EE_UPDATE_PRIMARY_DEVICE": 94,
        "SUCCESS": 95,
        "CANCEL": 96,
        "E2EE_PRIMARY_NOT_SUPPORT": 97,
        "E2EE_RETRY_PLAIN": 98,
        "E2EE_RECREATE_GROUP_KEY": 99,
        "E2EE_GROUP_TOO_MANY_MEMBERS": 100,
        "SERVER_BUSY": 101,
        "NOT_ALLOWED_ADD_FOLLOW": 102,
        "INCOMING_FRIEND_REQUEST_LIMIT": 103,
        "OUTGOING_FRIEND_REQUEST_LIMIT": 104,
        "OUTGOING_FRIEND_REQUEST_QUOTA": 105,
        "DUPLICATED": 106,
        "BANNED": 107,
    }

class LoginType(int):
    ID_CREDENTIAL = 0
    QRCODE = 1
    ID_CREDENTIAL_WITH_E2EE = 2

    _VALUES_TO_NAMES = {
        0: "ID_CREDENTIAL",
        1: "QRCODE",
        2: "ID_CREDENTIAL_WITH_E2EE",
    }

    _NAMES_TO_VALUES = {
        "ID_CREDENTIAL": 0,
        "QRCODE": 1,
        "ID_CREDENTIAL_WITH_E2EE": 2,
    }

class IdentityProvider(int):
    UNKNOWN = 0
    LINE = 1
    NAVER_KR = 2
    LINE_PHONE = 3

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "LINE",
        2: "NAVER_KR",
        3: "LINE_PHONE",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "LINE": 1,
        "NAVER_KR": 2,
        "LINE_PHONE": 3,
    }

class LoginResultType(int):
    SUCCESS = 1
    REQUIRE_QRCODE = 2
    REQUIRE_DEVICE_CONFIRM = 3
    REQUIRE_SMS_CONFIRM = 4

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "REQUIRE_QRCODE",
        3: "REQUIRE_DEVICE_CONFIRM",
        4: "REQUIRE_SMS_CONFIRM",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "REQUIRE_QRCODE": 2,
        "REQUIRE_DEVICE_CONFIRM": 3,
        "REQUIRE_SMS_CONFIRM": 4,
    }

class VerificationMethod(int):
    NO_AVAILABLE = 0
    PIN_VIA_SMS = 1
    CALLERID_INDIGO = 2
    PIN_VIA_TTS = 4
    SKIP = 10

    _VALUES_TO_NAMES = {
        0: "NO_AVAILABLE",
        1: "PIN_VIA_SMS",
        2: "CALLERID_INDIGO",
        4: "PIN_VIA_TTS",
        10: "SKIP",
    }

    _NAMES_TO_VALUES = {
        "NO_AVAILABLE": 0,
        "PIN_VIA_SMS": 1,
        "CALLERID_INDIGO": 2,
        "PIN_VIA_TTS": 4,
        "SKIP": 10,
    }

class LoginRequest(object):
    """
    Attributes:
     - type
     - identityProvider
     - identifier
     - password
     - keepLoggedIn
     - accessLocation
     - systemName
     - certificate
     - verifier
     - secret
     - e2eeVersion
    """
    def __init__(self, type=None, identityProvider=None, identifier=None, password=None, keepLoggedIn=None, accessLocation=None, systemName=None, certificate=None, verifier=None, secret=None, e2eeVersion=None):
        self.type = type
        self.identityProvider = identityProvider
        self.identifier = identifier
        self.password = password
        self.keepLoggedIn = keepLoggedIn
        self.accessLocation = accessLocation
        self.systemName = systemName
        self.certificate = certificate
        self.verifier = verifier
        self.secret = secret
        self.e2eeVersion = e2eeVersion

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = LoginType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.identityProvider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.keepLoggedIn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.accessLocation = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.systemName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.certificate = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.secret = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.e2eeVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('LoginRequest')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.identityProvider is not None:
            oprot.writeFieldBegin('identityProvider', TType.I32, 2)
            oprot.writeI32(self.identityProvider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 3)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password)
            oprot.writeFieldEnd()
        if self.keepLoggedIn is not None:
            oprot.writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
            oprot.writeBool(self.keepLoggedIn)
            oprot.writeFieldEnd()
        if self.accessLocation is not None:
            oprot.writeFieldBegin('accessLocation', TType.STRING, 6)
            oprot.writeString(self.accessLocation)
            oprot.writeFieldEnd()
        if self.systemName is not None:
            oprot.writeFieldBegin('systemName', TType.STRING, 7)
            oprot.writeString(self.systemName)
            oprot.writeFieldEnd()
        if self.certificate is not None:
            oprot.writeFieldBegin('certificate', TType.STRING, 8)
            oprot.writeString(self.certificate)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 9)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.secret is not None:
            oprot.writeFieldBegin('secret', TType.STRING, 10)
            oprot.writeBinary(self.secret)
            oprot.writeFieldEnd()
        if self.e2eeVersion is not None:
            oprot.writeFieldBegin('e2eeVersion', TType.I32, 11)
            oprot.writeI32(self.e2eeVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.identityProvider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.password))
        value = (value * 31) ^ hash(make_hashable(self.keepLoggedIn))
        value = (value * 31) ^ hash(make_hashable(self.accessLocation))
        value = (value * 31) ^ hash(make_hashable(self.systemName))
        value = (value * 31) ^ hash(make_hashable(self.certificate))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.secret))
        value = (value * 31) ^ hash(make_hashable(self.e2eeVersion))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class VerificationSessionData(object):
    """
    Attributes:
     - sessionId
     - method
     - callback
     - normalizedPhone
     - countryCode
     - nationalSignificantNumber
     - availableVerificationMethods
     - callerIdMask
    """
    def __init__(self, sessionId=None, method=None, callback=None, normalizedPhone=None, countryCode=None, nationalSignificantNumber=None, availableVerificationMethods=None, callerIdMask=None):
        self.sessionId = sessionId
        self.method = method
        self.callback = callback
        self.normalizedPhone = normalizedPhone
        self.countryCode = countryCode
        self.nationalSignificantNumber = nationalSignificantNumber
        self.availableVerificationMethods = availableVerificationMethods
        self.callerIdMask = callerIdMask

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.method = VerificationMethod(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.callback = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.normalizedPhone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.countryCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.nationalSignificantNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.availableVerificationMethods = []
                    (_, elem0) = iprot.readListBegin()
                    for _ in range(elem0):
                        elem1 = VerificationMethod(iprot.readI32())
                        self.availableVerificationMethods.append(elem1)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.callerIdMask = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('VerificationSessionData')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.I32, 2)
            oprot.writeI32(self.method)
            oprot.writeFieldEnd()
        if self.callback is not None:
            oprot.writeFieldBegin('callback', TType.STRING, 3)
            oprot.writeString(self.callback)
            oprot.writeFieldEnd()
        if self.normalizedPhone is not None:
            oprot.writeFieldBegin('normalizedPhone', TType.STRING, 4)
            oprot.writeString(self.normalizedPhone)
            oprot.writeFieldEnd()
        if self.countryCode is not None:
            oprot.writeFieldBegin('countryCode', TType.STRING, 5)
            oprot.writeString(self.countryCode)
            oprot.writeFieldEnd()
        if self.nationalSignificantNumber is not None:
            oprot.writeFieldBegin('nationalSignificantNumber', TType.STRING, 6)
            oprot.writeString(self.nationalSignificantNumber)
            oprot.writeFieldEnd()
        if self.availableVerificationMethods is not None:
            oprot.writeFieldBegin('availableVerificationMethods', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.availableVerificationMethods))
            for elem2 in self.availableVerificationMethods:
                oprot.writeI32(elem2)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.callerIdMask is not None:
            oprot.writeFieldBegin('callerIdMask', TType.STRING, 8)
            oprot.writeString(self.callerIdMask)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.method))
        value = (value * 31) ^ hash(make_hashable(self.callback))
        value = (value * 31) ^ hash(make_hashable(self.normalizedPhone))
        value = (value * 31) ^ hash(make_hashable(self.countryCode))
        value = (value * 31) ^ hash(make_hashable(self.nationalSignificantNumber))
        value = (value * 31) ^ hash(make_hashable(self.availableVerificationMethods))
        value = (value * 31) ^ hash(make_hashable(self.callerIdMask))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class LoginResult(object):
    """
    Attributes:
     - authToken
     - certificate
     - verifier
     - pinCode
     - type
     - lastPrimaryBindTime
     - displayMessage
     - sessionForSMSConfirm
    """
    def __init__(self, authToken=None, certificate=None, verifier=None, pinCode=None, type=None, lastPrimaryBindTime=None, displayMessage=None, sessionForSMSConfirm=None):
        self.authToken = authToken
        self.certificate = certificate
        self.verifier = verifier
        self.pinCode = pinCode
        self.type = type
        self.lastPrimaryBindTime = lastPrimaryBindTime
        self.displayMessage = displayMessage
        self.sessionForSMSConfirm = sessionForSMSConfirm

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.certificate = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = LoginResultType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.lastPrimaryBindTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.displayMessage = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.sessionForSMSConfirm = VerificationSessionData()
                    self.sessionForSMSConfirm.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('LoginResult')
        if self.authToken is not None:
            oprot.writeFieldBegin('authToken', TType.STRING, 1)
            oprot.writeString(self.authToken)
            oprot.writeFieldEnd()
        if self.certificate is not None:
            oprot.writeFieldBegin('certificate', TType.STRING, 2)
            oprot.writeString(self.certificate)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 3)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 4)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.lastPrimaryBindTime is not None:
            oprot.writeFieldBegin('lastPrimaryBindTime', TType.I64, 6)
            oprot.writeI64(self.lastPrimaryBindTime)
            oprot.writeFieldEnd()
        if self.displayMessage is not None:
            oprot.writeFieldBegin('displayMessage', TType.STRING, 7)
            oprot.writeString(self.displayMessage)
            oprot.writeFieldEnd()
        if self.sessionForSMSConfirm is not None:
            oprot.writeFieldBegin('sessionForSMSConfirm', TType.STRUCT, 8)
            self.sessionForSMSConfirm.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.authToken))
        value = (value * 31) ^ hash(make_hashable(self.certificate))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.lastPrimaryBindTime))
        value = (value * 31) ^ hash(make_hashable(self.displayMessage))
        value = (value * 31) ^ hash(make_hashable(self.sessionForSMSConfirm))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class E2EEPublicKey(object):
    """
    Attributes:
     - version
     - keyId
     - keyData
     - createdTime
    """
    def __init__(self, version=None, keyId=None, keyData=None, createdTime=None):
        self.version = version
        self.keyId = keyId
        self.keyData = keyData
        self.createdTime = createdTime

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.keyId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.keyData = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.createdTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('E2EEPublicKey')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 1)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.keyId is not None:
            oprot.writeFieldBegin('keyId', TType.I32, 2)
            oprot.writeI32(self.keyId)
            oprot.writeFieldEnd()
        if self.keyData is not None:
            oprot.writeFieldBegin('keyData', TType.STRING, 4)
            oprot.writeBinary(self.keyData)
            oprot.writeFieldEnd()
        if self.createdTime is not None:
            oprot.writeFieldBegin('createdTime', TType.I64, 5)
            oprot.writeI64(self.createdTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.version))
        value = (value * 31) ^ hash(make_hashable(self.keyId))
        value = (value * 31) ^ hash(make_hashable(self.keyData))
        value = (value * 31) ^ hash(make_hashable(self.createdTime))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class Profile(object):
    """
    Attributes:
     - mid
     - userid
     - phone
     - email
     - regionCode
     - displayName
     - phoneticName
     - pictureStatus
     - thumbnailUrl
     - statusMessage
     - allowSearchByUserid
     - allowSearchByEmail
     - picturePath
     - musicProfile
     - videoProfile
    """
    def __init__(self, mid=None, userid=None, phone=None, email=None, regionCode=None, displayName=None, phoneticName=None, pictureStatus=None, thumbnailUrl=None, statusMessage=None, allowSearchByUserid=None, allowSearchByEmail=None, picturePath=None, musicProfile=None, videoProfile=None):
        self.mid = mid
        self.userid = userid
        self.phone = phone
        self.email = email
        self.regionCode = regionCode
        self.displayName = displayName
        self.phoneticName = phoneticName
        self.pictureStatus = pictureStatus
        self.thumbnailUrl = thumbnailUrl
        self.statusMessage = statusMessage
        self.allowSearchByUserid = allowSearchByUserid
        self.allowSearchByEmail = allowSearchByEmail
        self.picturePath = picturePath
        self.musicProfile = musicProfile
        self.videoProfile = videoProfile

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.phone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.email = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.regionCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.displayName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.phoneticName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRING:
                    self.pictureStatus = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRING:
                    self.thumbnailUrl = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRING:
                    self.statusMessage = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.BOOL:
                    self.allowSearchByUserid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.BOOL:
                    self.allowSearchByEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.STRING:
                    self.picturePath = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.STRING:
                    self.musicProfile = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.STRING:
                    self.videoProfile = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('Profile')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 1)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 3)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        if self.phone is not None:
            oprot.writeFieldBegin('phone', TType.STRING, 10)
            oprot.writeString(self.phone)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 11)
            oprot.writeString(self.email)
            oprot.writeFieldEnd()
        if self.regionCode is not None:
            oprot.writeFieldBegin('regionCode', TType.STRING, 12)
            oprot.writeString(self.regionCode)
            oprot.writeFieldEnd()
        if self.displayName is not None:
            oprot.writeFieldBegin('displayName', TType.STRING, 20)
            oprot.writeString(self.displayName)
            oprot.writeFieldEnd()
        if self.phoneticName is not None:
            oprot.writeFieldBegin('phoneticName', TType.STRING, 21)
            oprot.writeString(self.phoneticName)
            oprot.writeFieldEnd()
        if self.pictureStatus is not None:
            oprot.writeFieldBegin('pictureStatus', TType.STRING, 22)
            oprot.writeString(self.pictureStatus)
            oprot.writeFieldEnd()
        if self.thumbnailUrl is not None:
            oprot.writeFieldBegin('thumbnailUrl', TType.STRING, 23)
            oprot.writeString(self.thumbnailUrl)
            oprot.writeFieldEnd()
        if self.statusMessage is not None:
            oprot.writeFieldBegin('statusMessage', TType.STRING, 24)
            oprot.writeString(self.statusMessage)
            oprot.writeFieldEnd()
        if self.allowSearchByUserid is not None:
            oprot.writeFieldBegin('allowSearchByUserid', TType.BOOL, 31)
            oprot.writeBool(self.allowSearchByUserid)
            oprot.writeFieldEnd()
        if self.allowSearchByEmail is not None:
            oprot.writeFieldBegin('allowSearchByEmail', TType.BOOL, 32)
            oprot.writeBool(self.allowSearchByEmail)
            oprot.writeFieldEnd()
        if self.picturePath is not None:
            oprot.writeFieldBegin('picturePath', TType.STRING, 33)
            oprot.writeString(self.picturePath)
            oprot.writeFieldEnd()
        if self.musicProfile is not None:
            oprot.writeFieldBegin('musicProfile', TType.STRING, 34)
            oprot.writeString(self.musicProfile)
            oprot.writeFieldEnd()
        if self.videoProfile is not None:
            oprot.writeFieldBegin('videoProfile', TType.STRING, 35)
            oprot.writeString(self.videoProfile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.userid))
        value = (value * 31) ^ hash(make_hashable(self.phone))
        value = (value * 31) ^ hash(make_hashable(self.email))
        value = (value * 31) ^ hash(make_hashable(self.regionCode))
        value = (value * 31) ^ hash(make_hashable(self.displayName))
        value = (value * 31) ^ hash(make_hashable(self.phoneticName))
        value = (value * 31) ^ hash(make_hashable(self.pictureStatus))
        value = (value * 31) ^ hash(make_hashable(self.thumbnailUrl))
        value = (value * 31) ^ hash(make_hashable(self.statusMessage))
        value = (value * 31) ^ hash(make_hashable(self.allowSearchByUserid))
        value = (value * 31) ^ hash(make_hashable(self.allowSearchByEmail))
        value = (value * 31) ^ hash(make_hashable(self.picturePath))
        value = (value * 31) ^ hash(make_hashable(self.musicProfile))
        value = (value * 31) ^ hash(make_hashable(self.videoProfile))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class AuthQrcode(object):
    """
    Attributes:
     - qrcode
     - verifier
     - callbackUrl
    """
    def __init__(self, qrcode=None, verifier=None, callbackUrl=None):
        self.qrcode = qrcode
        self.verifier = verifier
        self.callbackUrl = callbackUrl

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.qrcode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.callbackUrl = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('AuthQrcode')
        if self.qrcode is not None:
            oprot.writeFieldBegin('qrcode', TType.STRING, 1)
            oprot.writeString(self.qrcode)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.callbackUrl is not None:
            oprot.writeFieldBegin('callbackUrl', TType.STRING, 3)
            oprot.writeString(self.callbackUrl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.qrcode))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.callbackUrl))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class E2EEKey(object):
    """
    Attributes:
     - version
     - keyId
     - publicKey
     - privateKey
     - createdTime
    """
    def __init__(self, version=None, keyId=None, publicKey=None, privateKey=None, createdTime=None):
        self.version = version
        self.keyId = keyId
        self.publicKey = publicKey
        self.privateKey = privateKey
        self.createdTime = createdTime

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.keyId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.publicKey = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.privateKey = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.createdTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('E2EEKey')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 1)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.keyId is not None:
            oprot.writeFieldBegin('keyId', TType.I32, 2)
            oprot.writeI32(self.keyId)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRING, 4)
            oprot.writeBinary(self.publicKey)
            oprot.writeFieldEnd()
        if self.privateKey is not None:
            oprot.writeFieldBegin('privateKey', TType.STRING, 5)
            oprot.writeBinary(self.privateKey)
            oprot.writeFieldEnd()
        if self.createdTime is not None:
            oprot.writeFieldBegin('createdTime', TType.I64, 6)
            oprot.writeI64(self.createdTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.version))
        value = (value * 31) ^ hash(make_hashable(self.keyId))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.privateKey))
        value = (value * 31) ^ hash(make_hashable(self.createdTime))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class E2EEKeyChain(object):
    """
    Attributes:
     - keychain
    """
    def __init__(self, keychain=None):
        self.keychain = keychain

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keychain = []
                    (_, elem3) = iprot.readListBegin()
                    for _ in range(elem3):
                        elem4 = E2EEKey()
                        elem4.read(iprot)
                        self.keychain.append(elem4)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('E2EEKeyChain')
        if self.keychain is not None:
            oprot.writeFieldBegin('keychain', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.keychain))
            for elem5 in self.keychain:
                elem5.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.keychain))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class AuthException(TException):
    """
    Attributes:
     - code
     - reason
     - parameterMap
    """
    def __init__(self, code=None, reason=None, parameterMap=None):
        self.code = code
        self.reason = reason
        self.parameterMap = parameterMap

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.parameterMap = {}
                    (_, _, elem6) = iprot.readMapBegin()
                    for _ in range(elem6):
                        elem8 = iprot.readString()
                        elem7 = iprot.readString()
                        self.parameterMap[elem8] = elem7
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('AuthException')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        if self.parameterMap is not None:
            oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameterMap))
            for elem10, elem9 in self.parameterMap.items():
                oprot.writeString(elem10)
                oprot.writeString(elem9)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.code))
        value = (value * 31) ^ hash(make_hashable(self.reason))
        value = (value * 31) ^ hash(make_hashable(self.parameterMap))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class TalkException(TException):
    """
    Attributes:
     - code
     - reason
     - parameterMap
    """
    def __init__(self, code=None, reason=None, parameterMap=None):
        self.code = code
        self.reason = reason
        self.parameterMap = parameterMap

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.parameterMap = {}
                    (_, _, elem11) = iprot.readMapBegin()
                    for _ in range(elem11):
                        elem13 = iprot.readString()
                        elem12 = iprot.readString()
                        self.parameterMap[elem13] = elem12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('TalkException')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        if self.parameterMap is not None:
            oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameterMap))
            for elem15, elem14 in self.parameterMap.items():
                oprot.writeString(elem15)
                oprot.writeString(elem14)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.code))
        value = (value * 31) ^ hash(make_hashable(self.reason))
        value = (value * 31) ^ hash(make_hashable(self.parameterMap))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

